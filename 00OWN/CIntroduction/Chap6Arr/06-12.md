## C语言字符串处理函数

C语言提供了丰富的字符串处理函数，可以对字符串进行输入、输出、合并、修改、比较、转换、复制、搜索等操作，使用这些现成的函数可以大大减轻我们的编程负担。

用于输入输出的字符串函数，例如printf、puts、scanf、gets等，使用时要包含头文件stdio.h，而使用其它字符串函数要包含头文件string.h。

string.h是一个专门用来处理字符串的头文件，它包含了很多字符串处理函数，由于篇幅限制，本节只能讲解几个常用的，有兴趣的读者请猛击这里查阅所有函数。

###字符串连接函数 strcat()

strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：

```C
strcat(arrayName1, arrayName2);
```

arrayName1、arrayName2 为需要拼接的字符串。

strcat() 将把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志'\0'。这意味着，arrayName1 必须足够长，要能够同时容纳 arrayName1 和 arrayName2，否则会越界（超出范围）。

strcat() 的返回值为 arrayName1 的地址。

下面是一个简单的演示：

```C
#include <stdio.h>
#include <string.h>
int main(){
    char str1[100]="The URL is ";
    char str2[60];
    printf("Input a URL: ");
    gets(str2);
    strcat(str1, str2);
    puts(str1);

    return 0;
}
```

运行结果：
```
Input a URL: http://c.biancheng.net/cpp/u/jiaocheng/↙
The URL is http://c.biancheng.net/cpp/u/jiaocheng/
```

### 字符串复制函数 strcpy()

strcpy 是 string copy 的缩写，意思是字符串复制，也即将字符串从一个地方复制到另外一个地方，语法格式为：

```C
strcpy(arrayName1, arrayName2);
```

strcpy() 会把 arrayName2 中的字符串拷贝到 arrayName1 中，字符串结束标志'\0'也一同拷贝。请看下面的例子：

```C
#include <stdio.h>
#include <string.h>
int main(){
    char str1[50] = "《C语言变怪兽》";
    char str2[50] = "http://c.biancheng.net/cpp/u/jiaocheng/";
    strcpy(str1, str2);
    printf("str1: %s\n", str1);
    return 0;
}
```

运行结果：

```
str1: http://c.biancheng.net/cpp/u/jiaocheng/
```

你看，将 str2 复制到 str1 后，str1 中原来的内容就被覆盖了。

另外，strcat() 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。

### 字符串比较函数 strcmp()

strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：

```C
strcmp(arrayName1, arrayName2);
```

arrayName1 和 arrayName2 是需要比较的两个字符串。

字符本身没有大小之分，strcmp() 以各个字符对应的 ASCII 码值进行比较。strcmp() 从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾。

返回值：若 arrayName1 和 arrayName2 相同，则返回0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于0 的值。

对4组字符串进行比较：

```C
#include <stdio.h>
#include <string.h>
int main(){
    char a[] = "aBcDeF";
    char b[] = "AbCdEf";
    char c[] = "aacdef";
    char d[] = "aBcDeF";
    printf("a VS b: %d\n", strcmp(a, b));
    printf("a VS c: %d\n", strcmp(a, c));
    printf("a VS d: %d\n", strcmp(a, d));

    return 0;
}
```

运行结果：
```
a VS b: 32
a VS c: -31
a VS d: 0
```

------

## C语言数组是静态的，不能插入或删除元素

在C语言中，数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素，我们将这样的数组称为静态数组。

反过来说，如果数组在定义后可以改变容量，允许在任意位置插入或者删除元素，那么这样的数组称为动态数组。

PHP、JavaScript 等解释型的脚本语言一般都支持动态数组，而 C、C++ 等编译型的语言一般不支持动态数组。

总之，C语言中的数组是静态的，一旦定义后长度就不能改变了，大家要注意这一点，不要尝试去插入或删除元素。

如果由于项目要求，必须要在数组中插入或者删除元素，该怎么办呢？没办法，只能再造一个新数组！

下面的代码演示了数组元素的插入和删除操作：

```C
#include <stdio.h>
//自定义函数，用来输出数组元素
void display_array(int arr[], int len){
    int i;
    for(i=0; i<len; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}
int main()
{
    int nums[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int nums_new1[9];
    int nums_new2[11];
    int i;

    //删除nums第6个元素
    for(i=0; i<10; i++){
        //i等于6时直接跳过，不进行任何操作
        if(i < 6){
            nums_new1[i] = nums[i];
        }else if(i > 6){
            nums_new1[i-1] = nums[i];
        }
    }
    display_array(nums_new1, 9);

    //在nums第6个元素后面插入一个整数 55
    for(i=0; i<10; i++){
        if(i < 7){
            nums_new2[i] = nums[i];
        }else if(i > 7){
            nums_new2[i+1] = nums[i];
        }else {  //i等于6
            nums_new2[i] = 55;
            nums_new2[i+1] = nums[i];
        }
    }
    display_array(nums_new2, 11);

    return 0;
}
```

运行结果：

```
1 2 3 4 5 6 8 9 10
1 2 3 4 5 6 7 55 8 9 10
```

display_array() 是一个自己定义的函数，用来输出数组的所有元素；使用 display_array() 时，需要将数组名和数组长度传递给它。读者暂时知道这些即可，之后我们将在《C语言函数》一章中详细讲解。

这段代码总体的思路是使用 for 循环遍历所有的数组元素，并逐个给新的数组元素赋值。这种方法比较简单粗暴，更加高效和简洁的做法是直接复制数组内存，不过由于大家的知识还不充足，所以暂时无法讲解，等大家学了指针以后可以尝试使用 memcpy() 函数来解决。

### C语言数组为什么是静态的

不能插入和删除数组元素有时候会非常麻烦，比如一个数组保存了某个班级的学生学号，现在有一名学生退学了，就得把 TA 从数组中剔除，但是C语言并不支持这么做，这就给编程带来了不小的麻烦。

数组元素都是紧挨着排布的，中间没有空隙，不管是插入元素还是删除元素，都得移动该元素后面的内存：

- 在第 i 个元素后面插入一个新元素时，第 i 个元素后面的所有元素都要往后移动一个元素的位置，从而给新元素腾出位置来。如果该数组后面紧跟的是其它有用数据，那么为了防止覆盖有用数据，还不敢直接往后移动元素，必须得重新开辟一块内存，把所有的元素都复制过去。
- 删除第 i 个元素就比较简单了，不管三七二十一，把第 i 个元素后面的所有元素都向前移动即可。

插入和删除数组元素都要移动内存，甚至重新开辟一块内存，这是相当消耗资源的。如果一个程序中有大量的此类操作，那么程序的性能将堪忧，这有悖于「C语言非常高效」的初衷，所以C语言并不支持动态数组。

另外，很多时候我们需要把数组的地址保存到一个变量里面（等大家学到指针时就会见到这种情况），如果数组重新开辟了内存，而变量里面的地址不跟着改变的话，后续再使用该变量就会导致错误。让C语言本身去维护这些变量的值，以保持同步更新，这又是不可能做到的，所以这个矛盾无法从根本上解决。

总之，为了保证程序执行效率，为了防止操作错误，C语言只支持静态数组，不支持动态数组。

---------

## C语言数组的越界和溢出

### 数组越界

C语言数组是静态的，不能自动扩容，当下标小于零或大于等于数组长度时，就发生了越界（Out Of Bounds），访问到数组以外的内存。如果下标小于零，就会发生下限越界（Off Normal Lower）；如果下标大于等于数组长度，就会发生上限越界（Off Normal Upper）。

**C语言为了提高效率，保证操作的灵活性，并不会对越界行为进行检查，即使越界了，也能够正常编译，只有在运行期间才可能会发生问题。** 请看下面的代码：

```C
#include <stdio.h>
int main()
{
    int a[3] = {10, 20, 30}, i;
    for(i=-2; i<=4; i++) {
        printf("a[%d]=%d\n", i, a[i]);
    }
    return 0;
}
```

运行结果：

```
a[-2]=-858993460
a[-1]=-858993460
a[0]=10
a[1]=20
a[2]=30
a[3]=-858993460
a[4]=-858993460
```

越界访问的数组元素的值都是不确定的，没有实际的含义，因为数组之外的内存我们并不知道是什么，可能是其它变量的值，可能是函数参数，可能是一个地址，这些都是不可控的。

由于C语言的”放任“，我们访问数组时必须非常小心，要确保不会发生越界。每个C语言程序员的生涯中都遇到过越界错误，我拿项上人头作保证，所以千万不要大意，因为越界错误有时候不容易发现，也不容易复现。

当发生数组越界时，如果我们对该内存有使用权限，那么程序将正常运行，但会出现不可控的结果（如上例所示）；如果我们对该内存没有使用权限，或者该内存压根就没有被分配，那么程序将会崩溃。

### 数组溢出

当赋予数组的元素个数超过数组长度时，就会发生溢出（Overflow）。如下所示：

```C
int a[3] = {1, 2, 3, 4, 5};
```

数组长度为3，初始化时却赋予5个元素，超出了数组容量，所以只能保存前3个元素，后面的元素被丢弃。

GCC、LLVM/Clang、低版本的 VS（例如 VS2010）发现数组溢出只会给出警告，并不会报错。但是高版本的 VS（例如 VS2015、VS2017）发现数组溢出时会报错，禁止编译通过，微软终于聪明了一次。

**字符串的长度大于数组长度，数组只能容纳字符串的前面一部分，也就是"http://c.b"，即使编译器在最后添加了'\0'，它也保存不到数组里面，所以 printf() 扫描数组时不会遇到结束符'\0'，只能继续向后扫描。而后面内存中的数据我们不知道是什么，字符能否识别，何时遇到'\0'，这些都是不确定的。当字符无法识别时，就会出现乱码，显示奇怪的字符。**

**由此可见，在用字符串给字符数组赋值时，要保证数组长度大于字符串长度，以容纳结束符'\0'。**

------

## C语言变长数组(VLA)

在《C语言的三套标准，C语言为什么有这么多编译器》一节中我们讲到，目前经常使用的C语言有三个版本，分别是 C89、C99 和 C11。C89（也称 ANSI C）是较早的版本，也是最经典的版本，国内大学几乎都是以该版本为基础进行授课。C99 和 C11 是后来对 C89 的升级，增添了一些新内容（不多），语法更加灵活了，同时兼容 C89。

各种编译器都能很好地支持 C89 标准，但对 C99 的支持却不同：开源组织的 GCC 和 Xcode 使用的 LLVM/Clang 已经支持了大部分（几乎全部）的 C99 标准，而微软的 VC、VS 对 C99 却不感兴趣，直到后来的 VS2013、VS2015、VS2017 才慢慢支持，而且支持得还不好。

为什么要讨论这个问题呢？因为 C89 和 C99 对数组做出了不同的规定：

- 在 C89 中，必须使用常量表达式指明数组长度；也就是说，数组长度中不能包含变量，不管该变量有没有初始化。
- 而在 C99 中，可以使用变量指明数组长度。

下面的代码使用常量表达式指明数组长度，在任何编译器下都能编译通过：

```C
int a[10];  //长度为10
int b[3*5];  //长度为15
int c[4+8];  //长度为12
```

下面的代码使用变量指明数组长度，在 GCC 和 Xcode 下能够编译通过，而在 VC 和 VS（包括 VC 6.0、VS2010、VS2013、VS2015、VS2017 等）下都会报错：

```C
int m = 10, n;
scanf("%d", &n);
int a[m], b[n];
```

在实际编程中，有时数组的长度不能提前确定，如果这个变化范围小，那么使用常量表达式定义一个足够大的数组就可以，如果这个变化范围很大，就可能会浪费内存，这时就可以使用变长数组。请看下面的代码：

```C
#include <stdio.h>
int main()
{
    int n;
    printf("Input string length: ");
    scanf("%d", &n);
    scanf("%*[^\n]"); scanf("%*c");  //清空输入缓冲区
    char str[n];
    printf("Input a string: ");
    gets(str);
    puts(str);
    return 0;
}
```
在 GCC 和 Xcode 下的运行结果：
```
Input string length: 100↙
Input a string: http://c.biancheng.net/cpp/u/jiaocheng/↙
http://c.biancheng.net/cpp/u/jiaocheng/
```

变量的值在编译期间并不能确定，只有等到程序运行后，根据计算结果才能知道它的值到底是什么，所以数组长度中一旦包含了变量，那么数组长度在编译期间就不能确定了，也就不能为数组分配内存了，只有等到程序运行后，得到了变量的值，确定了具体的长度，才能给数组分配内存，我们将这样的数组称为变长数组(VLA, Variable Length Array)。

普通数组（固定长度的数组）是在编译期间分配内存的，而变长数组是在运行期间分配内存的。

### 变长数组仍然是静态数组
注意，变长数组是说数组的长度在定义之前可以改变，一旦定义了，就不能再改变了，所以变长数组的容量也是不能扩大或缩小的，它仍然是静态数组。以上面的代码为例，第 8 行代码是数组定义，此时就确定了数组的长度，在此之前长度可以随意改变，在此之后长度就固定了。

### 一种“自欺欺人”的写法

有些初学者在使用变长数组时会像下面一样书写代码：
```C
int n;
int arr[n];
scanf("%d", &n);
```

先定义一个变量 n 和一个数组 arr，然后用 scanf() 读入 n 的值。有些初学者认为，scanf() 输入结束后，n 的值就确认下来了，数组 arr 的长度也随即确定了。这种想法看似合理，其实是蛮不讲理，毫无根据。

从你定义数组的那一刻起（也就是第二行代码），数组的长度就确定下来了，以后再也不会改变了；改变 n 的值并不会影响数组长度，它们之间没有任何“联动”关系。用 scanf() 读入 n 的值，影响的也仅仅是 n 本身，不会影响数组。

那么，上面代码中数组的长度究竟是什么呢？鬼知道！n 是未初始化的局部变量，它的值是未知的。

修改上面的代码，将数组的定义放到最后就没问题了：
```C
int n;
scanf("%d", &n);
int arr[n];
```
在定义数组之前就输入 n 的值，这样输入的值才有用武之地。

-------------------

在实际开发中，有很多场景需要我们将数组元素按照从大到小（或者从小到大）的顺序排列，这样在查阅数据时会更加直观，例如：

- 一个保存了班级学号的数组，排序后更容易分区好学生和坏学生；
- 一个保存了商品单价的数组，排序后更容易看出它们的性价比。

对数组元素进行排序的方法有很多种，比如冒泡排序、归并排序、选择排序、插入排序、快速排序等，其中最经典最需要掌握的是「冒泡排序」。

以从小到大排序为例，冒泡排序的整体思想是这样的：

- 从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。
- 第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。
- 以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，就可以将所有的元素都排列好。

整个排序过程就好像气泡不断从水里冒出来，最大的先出来，次大的第二出来，最小的最后出来，所以将这种排序方式称为冒泡排序（Bubble Sort）。

下面我们以“3  2  4  1”为例对冒泡排序进行说明。

第一轮  排序过程
```
3  2  4  1    （最初）
2  3  4  2    （比较3和2，交换）
2  3  4  1    （比较3和4，不交换）
2  3  1  4    （比较4和1，交换）
```
第一轮结束，最大的数字 4 已经在最后面，因此第二轮排序只需要对前面三个数进行比较。

第二轮  排序过程
```
2  3  1  4 （第一轮排序结果）
2  3  1  4 （比较2和3，不交换）
2  1  3  4 （比较3和1，交换）
```
第二轮结束，次大的数字 3 已经排在倒数第二个位置，所以第三轮只需要比较前两个元素。

第三轮  排序过程
```
2  1  3  4  （第二轮排序结果）
1  2  3  4  （比较2和1，交换）
```

至此，排序结束。

### 算法总结及实现

对拥有 n 个元素的数组 R[n] 进行 n-1 轮比较。

第一轮，逐个比较 (R[1], R[2]),  (R[2], R[3]),  (R[3], R[4]),  …….  (R[N-1], R[N])，最大的元素被移动到 R[n] 上。

第二轮，逐个比较 (R[1], R[2]),  (R[2], R[3]),  (R[3], R[4]),  …….  (R[N-2], R[N-1])，次大的元素被移动到 R[n-1] 上。
。。。。。。
以此类推，直到整个数组从小到大排序。

具体的代码实现如下所示：

```C
#include <stdio.h>
int main(){

    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
    int i, j, temp;

    //冒泡排序算法：进行 n-1 轮比较
    for(i=0; i<10-1; i++){
        //每一轮比较前 n-1-i 个，也就是说，已经排序好的最后 i 个不用比较
        for(j=0; j<10-1-i; j++){
            if(nums[j] > nums[j+1]){
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }

    //输出排序后的数组
    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
    printf("\n");

    return 0;
}
```

```
运行结果：
1 2 3 4 5 6 7 8 9 10
```


### 优化算法

上面的算法是大部分教材中提供的算法，其中有一点是可以优化的：当比较到第 i 轮的时候，如果剩下的元素已经排序好了，那么就不用再继续比较了，跳出循环即可，这样就减少了比较的次数，提高了执行效率。

未经优化的算法一定会进行 n-1 轮比较，经过优化的算法最多进行 n-1 轮比较，高下立判。

优化后的算法实现如下所示：

```C
#include <stdio.h>

int main(){
    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
    int i, j, temp, isSorted;

    //优化算法：最多进行 n-1 轮比较
    for(i=0; i<10-1; i++){
        isSorted = 1;  //假设剩下的元素已经排序好了
        for(j=0; j<10-1-i; j++){
            if(nums[j] > nums[j+1]){
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
                isSorted = 0;  //一旦需要交换数组元素，就说明剩下的元素没有排序好
            }
        }
        if(isSorted) break; //如果没有发生交换，说明剩下的元素已经排序好了
    }
    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
    printf("\n");

    return 0;
}
```

我们额外设置了一个变量 isSorted，用它作为标志，值为“真”表示剩下的元素已经排序好了，值为“假”表示剩下的元素还未排序好。

每一轮比较之前，我们预先假设剩下的元素已经排序好了，并将 isSorted 设置为“真”，一旦在比较过程中需要交换元素，就说明假设是错的，剩下的元素没有排序好，于是将 isSorted 的值更改为“假”。

每一轮循环结束后，通过检测 isSorted 的值就知道剩下的元素是否排序好。

-------

## 对C语言数组的总结

数组（Array）是一系列相同类型的数据的集合，可以是一维的、二维的、多维的；最常用的是一维数组和二维数组，多维数组较少用到。

对数组的总结

1) 数组的定义格式为：

```C
type arrayName[length]
```

type 为数据类型，arrayName 为数组名，length 为数组长度。 需要注意的是：

- 数组长度 length 最好是常量表达式，例如 10、20*4 等，这样在所有编译器下都能运行通过；如果 length 中包含了变量，例如 n、4*m 等，在某些编译器下就会报错，我们已在《C语言变长数组(VLA)》一节专门讨论了这点。
- 数组是一个整体，它的内存是连续的；也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。
- 一般情况下，数组名会转换为数组的地址，需要使用地址的地方，直接使用数组名即可。

2) 访问数组元素的格式为：

```C
arrayName[index]
```

index 为数组下标。注意 index 的值必须大于等于零，并且小于数组长度，否则会发生数组越界，出现意想不到的错误，我们已在《C语言数组的越界和溢出》一节重点讨论过。

3) 可以对数组中的单个元素赋值，也可以整体赋值，例如：

```C
// 对单个元素赋值
int a[3];
a[0] = 3;
a[1] = 100;
a[2] = 34;

// 整体赋值（不指明数组长度）
float b[] = { 23.3, 100.00, 10, 0.34 };

// 整体赋值（指明数组长度）
int m[10] = { 100, 30, 234 };

// 字符数组赋值
char str1[] = "http://c.biancheng.net";

// 将数组所有元素都初始化为0
int arr[10] = {0};
char str2[20] = {0};
```

4) 字符串是本章的重点内容，大家要特别注意字符串结束标志'\0'，各种字符串处理函数在定位字符串时都把'\0'作为结尾，没有'\0'就到达不了字符串的结尾。

### 关于查找和排序

学完了数组，有两项内容大家可以深入研究了，分别是查找（Search）和排序（Sort），它们在实际开发中都经常使用，比如：

- 给你 10 个打乱顺序的整数，要能够按照从小到大或者从大到小的顺序输出；
- 给定一个字符串 str1，以及一个子串 str2，要能够判断 str2 是否在 str1 中。

-----

## C语言获取随机数

可能大家在编程的时候需要电脑来获取一些随机的反应，这个时候我们可以使用随机数，比较常见的是 rand() 函数，它可以随机的产生 0 ~ rand_max 的随机数。rand_max 是一个很大的数字，具体关系到IDE和数据类型，我们一般的需要不可能超出它的范围。

下面是一个实例：

```C
#include <stdio.h>
#include <stdlib.h>
int main(){
    int a=rand();
    printf("%d\n",a);
    return 0;
}
```

编译后再运行几次，你会发现产生的随机数是相同的。实际上，rand() 函数产生的随机数是伪随机数，是根据一个数按照某个公式推算出来的，这个数我们称之为“种子”，但是这个种子在系统启动之后就是一个定值，我们需要用 srand() 来进行播种，即在int a前加一句：

```C
srand((unsigned)time(NULL));     //这里利用时间进行播种，需要time.h
```

这样，我们就能得到不同的随机数，其实C语言中还有一个 random() 函数可以获取随机数，但是 random() 函数不是ANSI C标准，不能在VC等编译器通过，所以比较少用。

那如何产生一定范围的随机数呢？我们可以利用取模的方法：

```C
int a=rand()%10;    //产生0~9的随机数，注意10会被整除
```

如果要规定上下限：

```C
int a=rand()%51+13;    //产生13~63的随机数
```

分析：取模即取余，rand()%51+13我们可以看成2部分：rand()%51是产生0~50的随机数，后面+13保证a最小只能是13，最大就是50+13=63。

最后给出产生 13~63 范围内随机数的完整代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(){
    int a;
    srand((unsigned)time(NULL));
    a=rand()%51+13;
    printf("%d\n",a);
    return 0;
}
```
