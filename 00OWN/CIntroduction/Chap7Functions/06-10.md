## C语言局部变量和全局变量

**在《C语言函数的参数和返回值》中提到，形参变量要等到函数被调用时才分配内存，调用结束后立即释放内存。这说明形参变量的作用域非常有限，只能在函数内部使用，离开该函数就无效了。所谓作用域（Scope），就是变量的有效范围。**

不仅对于形参变量，C语言中所有的变量都有自己的作用域。决定变量作用域的是变量的定义位置。

### 局部变量

定义在函数内部的变量称为局部变量（Local Variable），它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。

例如：

```C
int f1(int a){
    int b,c;  //a,b,c仅在函数f1()内有效
    return a+b+c;
}
int main(){
    int m,n;  //m,n仅在函数main()内有效
    return 0;
}
```

几点说明：

1) 在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。

2) 形参变量、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。

3) 可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。

4) 在语句块中也可定义变量，它的作用域只限于当前语句块。

### 全局变量

**在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。** 例如：

```C
int a, b;  //全局变量
void func1(){
    //TODO:
}
float x,y;  //全局变量
int func2(){
    //TODO:
}
int main(){
    //TODO:
    return 0;
}
```
a、b、x、y 都是在函数外部定义的全局变量。C语言代码是从前往后依次执行的，由于 x、y 定义在函数 func1() 之后，所以在 func1() 内无效；而 a、b 定义在源程序的开头，所以在 func1()、func2() 和 main() 内都有效。

### 局部变量和全局变量的综合示例

【示例1】输出变量的值：
```C
#include <stdio.h>
int n = 10;  //全局变量
void func1(){
    int n = 20;  //局部变量
    printf("func1 n: %d\n", n);
}
void func2(int n){
    printf("func2 n: %d\n", n);
}
void func3(){
    printf("func3 n: %d\n", n);
}
int main(){
    int n = 30;  //局部变量
    func1();
    func2(n);
    func3();
    //代码块由{}包围
    {
        int n = 40;  //局部变量
        printf("block n: %d\n", n);
    }
    printf("main n: %d\n", n);
    return 0;
}
```
运行结果：
func1 n: 20
func2 n: 30
func3 n: 10
block n: 40
main n: 30

代码中虽然定义了多个同名变量 n，但它们的作用域不同，在内存中的位置（地址）也不同，所以是相互独立的变量，互不影响，不会产生重复定义（Redefinition）错误。

1) 对于 func1()，输出结果为 20，显然使用的是函数内部的 n，而不是外部的 n；func2() 也是相同的情况。

**当全局变量和局部变量同名时，在局部范围内全局变量被“屏蔽”，不再起作用。或者说，变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。**

2) func3() 输出 10，使用的是全局变量，因为在 func3() 函数中不存在局部变量 n，所以编译器只能到函数外部，也就是全局作用域中去寻找变量 n。

3) 由{ }包围的代码块也拥有独立的作用域，printf() 使用它自己内部的变量 n，输出 40。

3) C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。对于 main() 函数，即使代码块中的 n 离输出语句更近，但它仍然会使用 main() 函数开头定义的 n，所以输出结果是 30。

【示例2】根据长方体的长宽高求它的体积以及三个面的面积。
```c
#include <stdio.h>
int s1, s2, s3;  //面积
int vs(int a, int b, int c){
    int v;  //体积
    v = a * b * c;
    s1 = a * b;
    s2 = b * c;
    s3 = a * c;
    return v;
}
int main(){
    int v, length, width, height;
    printf("Input length, width and height: ");
    scanf("%d %d %d", &length, &width, &height);
    v = vs(length, width, height);
    printf("v=%d, s1=%d, s2=%d, s3=%d\n", v, s1, s2, s3);
    return 0;
}
```

运行结果：
Input length, width and height: 10 20 30↙
v=6000, s1=200, s2=600, s3=300

根据题意，我们希望借助一个函数得到三个值：体积 v 以及三个面的面积 s1、s2、s3。遗憾的是，C语言中的函数只能有一个返回值，我们只能将其中的一份数据，也就是体积 v 放到返回值中，而将面积 s1、s2、s3 设置为全局变量。全局变量的作用域是整个程序，在函数 vs() 中修改 s1、s2、s3 的值，能够影响到包括 main() 在内的其它函数。

## C语言变量的作用域，理解全局变量和局部变量

所谓作用域（Scope），就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在所有代码文件中使用，有些变量只能在当前的文件中使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。

**变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。** 本节我们只讲解两种变量，一种是只能在函数内部使用的变量，另一种是可以在所有代码文件中使用的变量。

### 在函数内部定义的变量（局部变量）

在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。函数的形参也是局部变量，也只能在函数内部使用。请看下面的例子：

```C
#include <stdio.h>
int sum(int m, int n){
    int i, sum=0;
    //m、n、i、sum 都是局部变量，只能在 sum() 内部使用
    for(i=m; i<=n; i++){
        sum+=i;
    }
    return sum;
}
int main(){
    int begin = 5, end = 86;
    int result = sum(begin, end);
    //begin、end、result 也都是局部变量，只能在 main() 内部使用
    printf("The sum from %d to %d is %d\n", begin, end, result);
    return 0;
}
```

m、n、i、sum 是局部变量，只能在 sum() 内部使用；begin、end、result 也是局部变量，只能在 main() 内部使用。

对局部变量的两点说明：

- main() 也是一个函数，在 main() 内部定义的变量也是局部变量，只能在 main() 函数内部使用。
- 形参也是局部变量，将实参传递给形参的过程，就是用实参给局部变量赋值的过程，它和a=b; sum=m+n;这样的赋值没有什么区别。

### 在所有函数外部定义的变量（全局变量）

C语言允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。

全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（.c文件）和头文件（.h文件）。如果给全局变量加上 static 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。我们目前编写的代码都是在一个源文件中，所以暂时不用考虑 static 关键字，后续我将会在《C语言模块化开发》专题中详细讲解。

【实例】定义一个函数，根据长方体的长宽高求它的体积以及三个面的面积。
```C
#include <stdio.h>
//定义三个全局变量，分别表示三个面的面积
int s1 = 0, s2 = 0, s3 = 0;
int vs(int length, int width, int height){
    int v;  //体积
    v = length * width * height;
    s1 = length * width;
    s2 = width * height;
    s3 = length * height;
    return v;
}
int main(){
    int v = 0;
    v = vs(15, 20, 30);
    printf("v=%d, s1=%d, s2=%d, s3=%d\n", v, s1, s2, s3);
    v = vs(5, 17, 8);
    printf("v=%d, s1=%d, s2=%d, s3=%d\n", v, s1, s2, s3);
    return 0;
}
```

运行结果：
v=9000, s1=300, s2=600, s3=450
v=680, s1=85, s2=136, s3=40

根据题意，我们希望借助一个函数得到四份数据：体积 v 以及三个面的面积 s1、s2、s3。遗憾的是，C语言中的函数只能有一个返回值，我们只能将其中的一份数据（也就是体积 v）放到返回值中，其它三份数据（也就是面积 s1、s2、s3）只能保存到全局变量中。

C语言代码从前往后依次执行，变量在使用之前必须定义或者声明，全局变量 s1、s2、s3 定义在程序开头，所以在 vs() 和 main() 中都有效。

在 vs() 中将求得的面积放到 s1、s2、s3 中，在 main() 中能够顺利取得它们的值，这说明：在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。

全局变量也是变量，变量只能保存一份数据，一旦数据被修改了，原来的数据就被冲刷掉了，再也无法恢复了，所以不管是全局变量还是局部变量，一旦它的值被修改，这种影响都会一直持续下去，直到再次被修改。

### 关于变量的命名

每一段可运行的C语言代码都包含了多个作用域，即使最简单的C语言代码也是如此。

```C
int main(){
    return 0;
}
```

这就是最简单的、可运行的C语言代码，它包含了两个作用域，一个是 main() 函数内部的局部作用域，一个是 main() 函数外部的全局作用域。

C语言规定，在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义：

- 不同函数内部可以出现同名的变量，不同函数是不同的局部作用域；
- 函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。

1) 不同函数内部的同名变量是两个完全独立的变量，它们之间没有任何关联，也不会相互影响。请看下面的代码：
```C
#include <stdio.h>
void func_a(){
    int n = 100;
    printf("func_a: n = %d\n", n);
    n = 86;
    printf("func_a: n = %d\n", n);
}
void func_b(){
    int n = 29;
    printf("func_b: n = %d\n", n);
    func_a(); //调用func_a()
    printf("func_b: n = %d\n", n);
}
int main(){
    func_b();
    return 0;
}
```

运行结果：
func_b: n = 29
func_a: n = 100
func_a: n = 86
func_b: n = 29

func_a() 和 func_b() 内部都定义了一个变量 n，在 func_b() 中，n 的初始值是 29，调用 func_a() 后，n 值还是 29，这说明 func_b() 内部的 n 并没有影响 func_a() 内部的 n。这两个 n 是完全不同的变量，彼此之间根本“不认识”，只是起了个相同的名字而已，这就好像明星撞衫，北京和云南都有叫李红的，赶巧了而已。

2) 函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。也就是说，在函数内部使用的是局部变量，而不是全局变量。

变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。另外，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。

下面我们通过一个具体的例子来说明：

```C
#include <stdio.h>
int n = 10;  //全局变量
void func1(){
    int n = 20;  //局部变量
    printf("func1 n: %d\n", n);
}
void func2(int n){
    printf("func2 n: %d\n", n);
}
void func3(){
    printf("func3 n: %d\n", n);
}
int main(){
    int n = 30;  //局部变量
    func1();
    func2(n);
    func3();
    printf("main n: %d\n", n);

    return 0;
}
```

运行结果：
func1 n: 20
func2 n: 30
func3 n: 10
main n: 30

代码中虽然定义了多个同名变量 n，但它们的作用域不同，所有不会产生命名冲突。

下面是对输出结果的分析：

- 对于 func1()，输出结果为 20，显然使用的是 func1() 内部的 n，而不是外部的 n。
- 调用 func2() 时，会把 main() 中的实参 n 传递给 func2() 中的形参 n，此时形参 n 的值变为 30。形参 n 也是局部变量，所以就使用它了。
- func3() 输出 10，使用的是全局变量，因为在 func3() 中不存在局部变量 n，所以编译器只能到函数外部，也就是全局作用域中去寻找变量 n。
- main() 中 printf() 语句输出 30，说明使用的是 main() 中的 n，而不是外部的 n。

## C语言块级变量，在代码块内部定义的变量

所谓代码块，就是由{ }包围起来的代码。代码块在C语言中随处可见，例如函数体、选择结构、循环结构等。不包含代码块的C语言程序根本不能运行，即使最简单的C语言程序（上节已经进行了展示）也要包含代码块。

**C语言允许在代码块内部定义变量，这样的变量具有块级作用域；换句话说，在代码块内部定义的变量只能在代码块内部使用，出了代码块就无效了。**

上节我们已经讲解了函数，在函数内部定义的变量叫做局部变量，这节我们接着讲解选择结构和循环结构。

【实例1】定义一个函数 gcd()，求两个整数的最大公约数。
```C
#include <stdio.h>
//函数声明
int gcd(int a, int b);  //也可以写作 int gcd(int, int);
int main(){
    printf("The greatest common divisor is %d\n", gcd(100, 60));
    return 0;
}
//函数定义
int gcd(int a, int b){
    //若a<b，那么交换两变量的值
    if(a < b){
        int temp1 = a;  //块级变量
        a = b;
        b = temp1;
    }

    //求最大公约数
    while(b != 0){
        int temp2 = b;  //块级变量
        b = a % b;
        a = temp2;
    }

    return a;
}
```
运行结果：

The greatest common divisor is 20

读者暂时不用理解 gcd() 函数的思路，只需要关注 temp1 和 temp2 这两个变量，它们都是在代码块内部定义的块级变量，temp1 的作用域是 if 内部，temp2 的作用域是 while 内部。

在 for 循环条件里面定义变量

遵循 C99 标准的编译器允许在 for 循环条件里面定义新变量，这样的变量也是块级变量，它的作用域仅限于 for 循环内部。例如，计算从 m 累加到 n 的和：
```C
#include <stdio.h>
int sum(int m, int n);
int main(){
    printf("The sum from 1 to 100 is %d\n", sum(1, 100));
    return 0;
}
int sum(int m, int n){
    int sum = 0;
    for(int i=m; i<=n; i++){  //i是块级变量
        sum += i;
    }
    return sum;
}
```

变量 i 定义在循环条件里面，所以是一个块级变量，它的作用域就是当前 for 循环，出了 for 循环就无效了。

如果一个变量只在 for 循环内部使用，就可以将它定义在循环条件里面，这样做可以避免在函数开头定义过多的变量，使得代码结构更加清晰，所以我鼓励大家这样做，当然，前提是你的编译器支持。

【实例2】定义一个函数 strchar()，查看给定的字符是否位于某个字符串中。

```C
#include <stdio.h>
#include <string.h>
int strchar(char *str, char c);
int main(){
    char url[] = "http://c.biancheng.net";
    char letter = 'c';
    if(strchar(url, letter) >= 0){
        printf("The letter is in the string.\n");
    }else{
        printf("The letter is not in the string.\n");
    }
    return 0;
}
int strchar(char *str, char c){
    for(int i=0,len=strlen(str); i<len; i++){  //i和len都是块级变量
        if(str[i] == c){
            return i;
        }
    }

    return -1;
}
```

循环条件里面可以定义一个或者多个变量，这段代码我们就定义了两个变量，分别是 i 和 len，它们都是块级变量，作用域都是当前 for 循环。

### 单独的代码块

C语言还允许出现单独的代码块，它也是一个作用域。请看下面的代码：

```C
#include <stdio.h>

int main(){
    int n = 22;  //编号①
    //由{ }包围的代码块
    {
        int n = 40;  //编号②
        printf("block n: %d\n", n);
    }
    printf("main n: %d\n", n);

    return 0;
}
```

运行结果：
block n: 40
main n: 22

这里有两个 n，它们位于不同的作用域，不会产生命名冲突。{ } 的作用域比 main() 更小，{ } 内部的 printf() 使用的是编号为②的 n，main() 内部的 printf() 使用的是编号为①的 n。

### 再谈作用域

每个C语言程序都包含了多个作用域，不同的作用域中可以出现同名的变量，C语言会按照从小到大的顺序、一层一层地去父级作用域中查找变量，如果在最顶层的全局作用域中还未找到这个变量，那么就会报错。

下面我们通过具体的代码来演示：
```C
#include <stdio.h>
int m = 13;
int n = 10;
void func1(){
    int n = 20;
    {
        int n = 822;
        printf("block1 n: %d\n", n);
    }
    printf("func1 n: %d\n", n);
}
void func2(int n){
    for(int i=0; i<10; i++){
        if(i % 5 == 0){
            printf("if m: %d\n", m);
        } else {
            int n = i % 4;
            if(n<2 && n>0) {
                printf("else m: %d\n", m);
            }
        }
    }
    printf("func2 n: %d\n", n);
}
void func3(){
    printf("func3 n: %d\n", n);
}
int main(){
    int n = 30;
    func1();
    func2(n);
    func3();
    printf("main n: %d\n", n);

    return 0;
}
```

下图展示了这段代码的作用域：

蓝色表示作用域的名称，红色表示作用域中的变量，global 表示全局作用域。在灰色背景的作用域中，我们使用到了 m 变量，而该变量位于全局作用域中，所以得穿越好几层作用域才能找到 m。

**一个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。** 执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。

下面我们通过一个求阶乘的例子，看看递归函数到底是如何运作的。阶乘 n! 的计算公式如下：

![](./Chap-07-0709-01-fomularofrec.gif)

根据公式编程：

```C
long factorial(int n){
    long result;
    if(n==0 || n==1){
        result = 1;
    }else{
        result = factorial(n-1) * n;  // 递归调用
    }
    return result;
}
```

这是一个典型的递归函数。调用 factorial() 后即进入函数体，只有当 n==0 或 n==1 时函数才会执行结束，否则就一直调用它自身。

由于每次调用的实参为 n-1，即把 n-1 的值赋给形参 n，所以每次递归实参的值都减 1，直到最后 n-1 的值为 1 时再作递归调用，形参 n 的值也为1，递归就终止了，会逐层退出。

例如求 5!，即调用factorial(5)。当进入 factorial() 函数体后，由于 n=5，不等于0或1，所以执行result = factorial(n-1) * n;，即result = factorial(5-1) * 5;，接下来也就是调用factorial(4)。这是第一次递归。

进行四次递归调用后，实参的值为 1，也就是调用factorial(1)。这时递归就结束了，开始逐层返回。factorial(1) 的值为 1，factorial(2) 的值为 1*2=2，factorial(3) 的值为 2*3=6，factorial(4) 的值为 6*4=24，最后返回值 factorial(5) 为 24*5=120。

> 注意：为了防止递归调用无终止地进行，必须在函数内有终止递归调用的手段。常用的办法是加条件判断，满足某种条件后就不再作递归调用，然后逐层返回。

递归调用不但难于理解，而且开销很大，如非必要，不推荐使用递归。很多递归调用可以用迭代（循环）来代替。

【示例】用迭代法求 n!。

```C
long factorial(int n){
    int i;
    long result=1;
    if(n==0 || n==1){
        return 1;
    }
    for(i=1; i<=n; i++){
        result *= i;
    }
    return result;
}
```

## 忽略语法细节，从整体上理解函数
从整体上看，C语言代码是由一个一个的函数构成的，除了定义和说明类的语句（例如变量定义、宏定义、类型定义等）可以放在函数外面，所有具有运算或逻辑处理能力的语句（例如加减乘除、if else、for、函数调用等）都要放在函数内部。

例如，下面的代码就是错误的：
```C
#include <stdio.h>
int a = 10;
int b = a + 20;
int main(){
    return 0;
}
```

int b = a + 20;是具有运算功能的语句，要放在函数内部。

但是下面的代码就是正确的：
```C
#include <stdio.h>
int a = 10;
int b = 10 + 20;
int main(){
    return 0;
}
```

int b = 10 + 20;在编译时会被优化成int b = 30;，消除加法运算。

在所有的函数中，main() 是入口函数，有且只能有一个，C语言程序就是从这里开始运行的。

C语言不但提供了丰富的库函数，还允许用户定义自己的函数。**每个函数都是一个可以重复使用的模块，通过模块间的相互调用，有条不紊地实现复杂的功能。可以说C程序的全部工作都是由各式各样的函数完成的，所以也把C语言称为函数式语言。**

标准C语言（ANSI C）共定义了15 个头文件，称为“C标准库”，所有的编译器都必须支持，如何正确并熟练的使用这些标准库，可以反映出一个程序员的水平。

- 合格程序员：<stdio.h>、<ctype.h>、<stdlib.h>、<string.h>
- 熟练程序员：<assert.h>、<limits.h>、<stddef.h>、<time.h>
- 优秀程序员：<float.h>、<math.h>、<error.h>、<locale.h>、<setjmp.h>、<signal.h>、<stdarg.h>

以上各类函数不仅数量众多，而且有的还需要硬件知识才能使用，初学者要想全部掌握得需要一个较长的学习过程。我的建议是先掌握一些最基本、最常用的函数，在实践过程中再逐步深入。由于课时关系，本教程只介绍了很少一部分库函数，其余部分读者可根据需要查阅C语言函数手册，网址是
`http://www.cplusplus.com。`

还应该指出的是，C语言中所有的函数定义，包括主函数 main() 在内，都是平行的。也就是说，在一个函数的函数体内，不能再定义另一个函数，即不能嵌套定义。但是函数之间允许相互调用，也允许嵌套调用。习惯上把调用者称为主调函数，被调用者称为被调函数。函数还可以自己调用自己，称为递归调用。

main() 函数是主函数，它可以调用其它函数，而不允许被其它函数调用。因此，C程序的执行总是从 main() 函数开始，完成对其它函数的调用后再返回到 main() 函数，最后由 main() 函数结束整个程序。
