## C语言整数的取值范围以及数值溢出

short、int、long 是C语言中常用的三种整数类型，分别称为短整型、整型、长整型。

在现代操作系统中，short、int、long 的长度分别是 2、4、4 或者 8，它们只能存储有限的数值，当数值过大或者过小时，超出的部分会被直接截掉，数值就不能正确存储了，我们将这种现象称为溢出（Overflow）。

溢出的简单理解就是，向木桶里面倒入了过量的水，木桶盛不了了，水就流出来了。

要想知道数值什么时候溢出，就得先知道各种整数类型的取值范围。

### 无符号数的取值范围

计算无符号数（unsigned 类型）的取值范围（或者说最大值和最小值）很容易，将内存中的所有位（Bit）都置为 1 就是最大值，都置为 0 就是最小值。

以 unsigned char 类型为例，它的长度是 1，占用 8 位的内存，所有位都置为 1 时，它的值为 28 - 1 = 255，所有位都置为 0 时，它的值很显然为 0。由此可得，unsigned char 类型的取值范围是 0~255。

> 前面我们讲到，char 是一个字符类型，是用来存放字符的，但是它同时也是一个整数类型，也可以用来存放整数，请大家暂时先记住这一点，更多细节我们将在《C语言中的字符（char）》一节中介绍。

有读者可能会对 unsigned char 的最大值有疑问，究竟是怎么计算出来的呢？下面我就讲解一下这个小技巧。

将 unsigned char 的所有位都置为 1，它在内存中的表示形式为1111 1111，最直接的计算方法就是：
```
2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 = 255
```

这种“按部就班”的计算方法虽然有效，但是比较麻烦，如果是 8 个字节的 long 类型，那足够你计算半个小时的了。

我们不妨换一种思路，先给 1111 1111 加上 1，然后再减去 1，这样一增一减正好抵消掉，不会影响最终的值。

给 1111 1111 加上 1 的计算过程为：
```
0B1111 1111 + 0B1 = 0B1 0000 0000 = 28 = 256
```
可以发现，1111 1111 加上 1  后需要向前进位（向第 9 位进位），剩下的 8 位都变成了 0，这样一来，只有第 9 位会影响到数值的计算，剩下的 8 位对数值都没有影响。第 9 位的权值计算起来非常容易，就是：

```
2^(9-1) = 2^8 = 256
```

然后再减去 1：
```
2^8 - 1 = 256 - 1 = 255
```

加上 1 是为了便于计算，减去 1 是为了还原本来的值；当内存中所有的位都是 1 时，这种“凑整”的技巧非常实用。

按照这种巧妙的方法，我们可以很容易地计算出所有无符号数的取值范围（括号内为假设的长度）：

||unsigned char|unsigned short|unsigned int（4字节）|unsigned long（8字节）|
|---|---|---|
|最小值|0|0|0|0|
|最大值|2^8 - 1 = 255|2^16 - 1 = 65,535 ≈ 6.5万|2^32 - 1 = 4,294,967,295 ≈ 42亿|2^64 - 1 ≈ 1.84×10^19|

###有符号数的取值范围
有符号数以补码的形式存储，计算取值范围也要从补码入手。我们以 char 类型为例，从下表中找出它的取值范围：

|补码|反码|原码|值|
|--|
|1111 1111|1111 1110|1000 0001|-1|
|1111 1110|1111 1101|1000 0010|-2|
|1111 1101|1111 1100|1000 0011|-3|
|……|……|……|……|
|1000 0011|1000 0010|1111 1101|-125|
|1000 0010|1000 0001|1111 1110|-126|
|1000 0001|1000 0000|1111 1111|-127|
|1000 0000|--|--|-128|
|0111 1111|0111 1111|0111 1111|127|
|0111 1110|0111 1110|0111 1110|126|
|0111 1101|0111 1101|0111 1101|125|
|……|……|……|……|
|0000 0010|0000 0010|0000 0010|2|
|0000 0001|0000 0001|0000 0001|1|
|0000 0000|0000 0000|0000 0000|0|

其次，我们再按照“传统”的方法计算一下 -128 的补码：

- -128 的数值位的原码是 1000 0000，共八位，而 char 的数值位只有七位，所以最高位的 1 会覆盖符号位，数值位剩下 000 0000。最终，-128 的原码为 1000 0000。
- 接着很容易计算出反码，为 1111 1111。
- 反码转换为补码时，数值位要加上 1，变为 1000 0000，而 char 的数值位只有七位，所以最高位的 1 会再次覆盖符号位，数值位剩下 000 0000。最终求得的 -128 的补码是 1000 0000。

-128 从原码转换到补码的过程中，符号位被 1 覆盖了两次，而负数的符号位本来就是 1，被 1 覆盖多少次也不会影响到数字的符号。

你看，虽然从 1000 0000 这个补码推算不出 -128，但是从 -128 却能推算出 1000 0000 这个补码，这么多么的奇妙，-128 这个特殊值选得恰到好处。

负数在存储之前要先转换为补码，“从 -128 推算出补码 1000 0000”这一点非常重要，这意味着 -128 能够正确地转换为补码，或者说能够正确的存储。

### 关于零值和最小值

仔细观察上表可以发现，在 char 的取值范围内只有一个零值，没有+0和-0的区别，并且多存储了一个特殊值，就是 -128，这也是采用补码的另外两个小小的优势。

如果直接采用原码存储，那么0000 0000和1000 0000将分别表示+0和-0，这样在取值范围内就存在两个相同的值，多此一举。另外，虽然最大值没有变，仍然是 127，但是最小值却变了，只能存储到 -127，不能存储 -128 了，因为 -128 的原码为 1000 0000，这个位置已经被-0占用了。

按照上面的方法，我们可以计算出所有有符号数的取值范围（括号内为假设的长度）：

| |char|short|int（4个字节）|long（8个字节）|
|--|
|最小值|-27 = -128|-2^15 = -32,768 ≈ -3.2万|-2^31 = -2,147,483,648 ≈ -21亿|-2^63 ≈ -9.22×1018|
|最大值|27 - 1= 127|2^15 - 1 = 32,767 ≈ 3.2万|2^31 - 1 = 2,147,483,647 ≈ 21亿|2^63 - 1≈ 9.22×1018|

上节我们还留下了一个疑问，[1000 0000 …… 0000 0000]补这个 int 类型的补码为什么对应的数值是 -2^31，有了本节对 char 类型的分析，相信聪明的你会举一反三，自己解开这个谜团。

### 数值溢出

char、short、int、long 的长度是有限的，当数值过大或者过小时，有限的几个字节就不能表示了，就会发生溢出。发生溢出时，输出结果往往会变得奇怪，请看下面的代码：

```C
#include <stdio.h>
int main()
{
    unsigned int a = 0x100000000;
    int b = 0xffffffff;
    printf("a=%u, b=%d\n", a, b);
    return 0;
}
```

运行结果：
a=0, b=-1

**变量 a 为 unsigned int 类型，长度为 4 个字节，能表示的最大值为 0xFFFFFFFF，而 0x100000000 = 0xFFFFFFFF + 1，占用33位，已超出 a 所能表示的最大值，所以发生了溢出，导致最高位的 1 被截去，剩下的 32 位都是0。也就是说，a 被存储到内存后就变成了 0，printf 从内存中读取到的也是 0。**

变量 b 是 int 类型的有符号数，在内存中以补码的形式存储。0xffffffff 的数值位的原码为 1111 1111 …… 1111 1111，共 32 位，而 int 类型的数值位只有 31 位，所以最高位的 1 会覆盖符号位，数值位只留下 31 个 1，所以 b 的原码为：
```C
1111 1111 …… 1111 1111
```

这也是 b 在内存中的存储形式。

当 printf 读取到 b 时，由于最高位是 1，所以会被判定为负数，要从补码转换为原码：

```C
[1111 1111 …… 1111 1111]补
= [1111 1111 …… 1111 1110]反
= [1000 0000 …… 0000 0001]原
= -1
```

最终 b 的输出结果为 -1。

## C语言中的小数（float,double）

小数分为整数部分和小数部分，它们由点号.分隔，例如 0.0、75.0、4.023、0.27、-937.198 -0.27 等都是合法的小数，这是最常见的小数形式，我们将它称为十进制形式。

此外，小数也可以采用指数形式，例如 7.25×10^2、0.0368×10^5、100.22×10^-2、-27.36×10^-3 等。任何小数都可以用指数形式来表示。

C语言同时支持以上两种形式的小数。但是在书写时，C语言中的指数形式和数学中的指数形式有所差异。

C语言中小数的指数形式为：

```
aEn 或 aen
```

a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。

指数形式的小数举例：

- 2.1E5 = 2.1×10^5，其中 2.1 是尾数，5 是指数。
- 3.7E-2 = 3.7×10^-2，其中 3.7 是尾数，-2 是指数。
- 0.5E7 = 0.5×10^7，其中 0.5 是尾数，7 是指数。

C语言中常用的小数有两种类型，分别是 float 或 double；float 称为单精度浮点型，double 称为双精度浮点型。

**不像整数，小数没有那么多幺蛾子，小数的长度是固定的，float 始终占用4个字节，double 始终占用8个字节。**

### 小数的输出

小数也可以使用 printf 函数输出，包括十进制形式和指数形式，它们对应的格式控制符分别是：

- %f 以十进制形式输出 float 类型；
- %lf 以十进制形式输出 double 类型；
- %e 以指数形式输出 float 类型，输出结果中的 e 小写；
- %E 以指数形式输出 float 类型，输出结果中的 E 大写；
- %le 以指数形式输出 double 类型，输出结果中的 e 小写；
- %lE 以指数形式输出 double 类型，输出结果中的 E 大写。

下面的代码演示了小数的表示以及输出：

```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float a = 0.302;
    float b = 128.101;
    double c = 123;
    float d = 112.64E3;
    double e = 0.7623e-2;
    float f = 1.23002398;
    printf("a=%e \nb=%f \nc=%lf \nd=%lE \ne=%lf \nf=%f\n", a, b, c, d, e, f);

    return 0;
}
```

运行结果：
a=3.020000e-01
b=128.100998
c=123.000000
d=1.126400E+05
e=0.007623
f=1.230024

对代码的说明：

1) %f 和 %lf 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。

2) 将整数赋值给 float 变量时会变成小数。

3) 以指数形式输出小数时，输出结果为科学计数法；也就是说，尾数部分的取值为：0 ≤ 尾数 < 10。

4) b 的输出结果让人费解，才三位小数，为什么不能精确输出，而是输出一个近似值呢？这和小数在内存中的存储形式有关，很多简单的小数压根不能精确存储，所以也就不能精确输出，我们将在下节《小数在内存中是如何存储的，揭秘诺贝尔奖级别的设计（长篇神文）》中详细讲解。

另外，小数还有一种更加智能的输出方式，就是使用%g。%g 会对比小数的十进制形式和指数形式，以最短的方式来输出小数，让输出结果更加简练。所谓最短，就是输出结果占用最少的字符。

%g 使用示例：

```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float a = 0.00001;
    float b = 30000000;
    float c = 12.84;
    float d = 1.229338455;
    printf("a=%g \nb=%g \nc=%g \nd=%g\n", a, b, c, d);

    return 0;
}
```

运行结果：
a=1e-05
b=3e+07
c=12.84
d=1.22934

对各个小数的分析：

- a 的十进制形式是 0.00001，占用七个字符的位置，a 的指数形式是 1e-05，占用五个字符的位置，指数形式较短，所以以指数的形式输出。
- b 的十进制形式是 30000000，占用八个字符的位置，b 的指数形式是 3e+07，占用五个字符的位置，指数形式较短，所以以指数的形式输出。
- c 的十进制形式是 12.84，占用五个字符的位置，c 的指数形式是 1.284e+01，占用九个字符的位置，十进制形式较短，所以以十进制的形式输出。
- d 的十进制形式是 1.22934，占用七个字符的位置，d 的指数形式是 1.22934e+00，占用十一个字符的位置，十进制形式较短，所以以十进制的形式输出。

读者需要注意的两点是：

- %g 默认最多保留六位有效数字，包括整数部分和小数部分；%f 和 %e 默认保留六位小数，只包括小数部分。
- %g 不会在最后强加 0 来凑够有效数字的位数，而 %f 和 %e 会在最后强加 0 来凑够小数部分的位数。

总之，%g 要以最短的方式来输出小数，并且小数部分表现很自然，不会强加零，比 %f 和 %e 更有弹性，这在大部分情况下是符合用户习惯的。

除了 %g，还有 %lg、%G、%lG：

- %g 和 %lg 分别用来输出 float 类型和 double 类型，并且当以指数形式输出时，e小写。
- %G 和 %lG 也分别用来输出 float 类型和 double 类型，只是当以指数形式输出时，E大写。

### 数字的后缀

一个数字，是有默认类型的：对于整数，默认是 int 类型；对于小数，默认是 double 类型。

请看下面的例子：

```C
long a = 100;
int b = 294;
float x = 52.55;
float y = 18.6;
```

100 和 294 这两个数字默认都是 int 类型的，将 100 赋值给 a，必须先从 int 类型转换为 long 类型，而将 294 赋值给 b 就不用转换了。

**52.55 和 18.6 这两个数字默认都是 double 类型的，将 52.55 赋值给 x，必须先从 double 类型转换为 float 类型，而将 18.6 赋值给 y 就不用转换了。**

> double的速度要比float快可能就是这个原因，56.6这个是double ,然而float需要截一下内存

如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型：

- 在整数后面紧跟 l 或者 L（不区分大小写）表明该数字是 long 类型；
- 在小数后面紧跟 f 或者 F（不区分大小写）表明该数字是 float 类型。

请看下面的代码：

```C
long a = 100l;
int b = 294;
short c = 32L;

float x = 52.55f;
double y = 18.6F;
float z = 0.02;
```

加上后缀，虽然数字的类型变了，但这并不意味着该数字只能赋值给指定的类型，它仍然能够赋值给其他的类型，只要进行了一下类型转换就可以了。

对于初学者，很少会用到数字的后缀，加不加往往没有什么区别，也不影响实际编程，但是既然学了C语言，还是要知道这个知识点的，万一看到别人的代码这么用了，而你却不明白怎么回事，那就尴尬了。

> 关于数据类型的转换，我们将在《C语言数据类型转换》一节中深入探讨。

### 小数和整数相互赋值

在C语言中，整数和小数之间可以相互赋值：

- 将一个整数赋值给小数类型，在小数点后面加 0 就可以，加几个都无所谓。
- 将一个小数赋值给整数类型，就得把小数部分丢掉，只能取整数部分，这会改变数字本来的值。注意是直接丢掉小数部分，而不是按照四舍五入取近似值。

请看下面的代码：
```C

#include <stdio.h>
int main(){
    float f = 251;
    int w = 19.427;
    int x = 92.78;
    int y = 0.52;
    int z = -87.27;

    printf("f = %f, w = %d, x = %d, y = %d, z = %d\n", f, w, x, y, z);
    return 0;
}
```

由于将小数赋值给整数类型时会“失真”，所以编译器一般会给出警告，让大家引起注意。

## 小数在内存中是如何存储的，揭秘诺贝尔奖级别的设计（长篇神文）

-------

## C语言处理英文字符

前面我们多次提到了字符串，字符串是多个字符的集合，它们由" "包围，例如"http://c.biancheng.net"、"C语言中文网"。**字符串中的字符在内存中按照次序、紧挨着排列，整个字符串占用一块连续的内存。**

当然，字符串也可以只包含一个字符，例如"A"、"6"；不过为了操作方便，我们一般使用专门的字符类型来处理。

**初学者经常用到的字符类型是 char，它的长度是 1，只能容纳 ASCII 码表中的字符，也就是英文字符。**

要想处理汉语、日语、韩语等英文之外的字符，就得使用其他的字符类型，char 是做不到的，我们将在下节《C语言处理中文字符》中详细讲解。

> char是Java中的保留字，与别的语言不同的是，char在Java中是16位的，因为Java用的是Unicode。不过8位的ASCII码包含在Unicode中，是从0~127的。

### 字符的表示

```C
//正确的写法
char a = '1';
char b = '$';
char c = 'X';
char d = ' ';  // 空格也是一个字符
//错误的写法
char x = '中';  //char 类型不能包含 ASCII 编码之外的字符
char y = 'Ａ';  //A 是一个全角字符
char z = "t";  //字符类型应该由单引号包围
```

说明：在字符集中，全角字符和半角字符对应的编号（或者说编码值）不同，是两个字符；ASCII 编码只定义了半角字符，没有定义全角字符。

### 字符的输出

输出 char 类型的字符有两种方法，分别是：

- 使用专门的字符输出函数 putchar；
- 使用通用的格式化输出函数 printf，char 对应的格式控制符是%c。

请看下面的演示：

```C
#include <stdio.h>
int main() {
    char a = '1';
    char b = '$';
    char c = 'X';
    char d = ' ';
    //使用 putchar 输出
    putchar(a); putchar(d);putchar(b);
    putchar(d); putchar(c); putchar('\n');
    //使用 printf 输出
    printf("%c %c %c\n", a, b, c);
    return 0;
}
```

运行结果：
1 $ X
1 $ X

putchar 函数每次只能输出一个字符，输出多个字符需要调用多次。

### 字符与整数

**我们知道，计算机在存储字符时并不是真的要存储字符实体，而是存储该字符在字符集中的编号（也可以叫编码值）。对于 char 类型来说，它实际上存储的就是字符的 ASCII 码。**

**无论在哪个字符集中，字符编号都是一个整数；从这个角度考虑，字符类型和整数类型本质上没有什么区别。**

我们可以给字符类型赋值一个整数，或者以整数的形式输出字符类型。反过来，也可以给整数类型赋值一个字符，或者以字符的形式输出整数类型。

请看下面的例子：
```C
#include <stdio.h>
int main()
{
    char a = 'E';
    char b = 70;
    int c = 71;
    int d = 'H';
    printf("a: %c, %d\n", a, a);
    printf("b: %c, %d\n", b, b);
    printf("c: %c, %d\n", c, c);
    printf("d: %c, %d\n", d, d);
    return 0;
}
```

输出结果：
a: E, 69
b: F, 70
c: G, 71
d: H, 72

在 ASCII 码表中，字符 'E'、'F'、'G'、'H' 对应的编号分别是 69、70、71、72。

a、b、c、d 实际上存储的都是整数：

- 当给 a、d 赋值一个字符时，字符会先转换成 ASCII 码再存储；
- 当给 b、c 赋值一个整数时，不需要任何转换，直接存储就可以；
- 当以 %c 输出 a、b、c、d 时，会根据 ASCII 码表将整数转换成对应的字符；
- 当以 %d 输出 a、b、c、d 时，不需要任何转换，直接输出就可以。

可以说，是 ASCII 码表将英文字符和整数关联了起来。

### 再谈字符串

**前面我们讲到了字符串的概念，也讲到了字符串的输出，但是还没有讲如何用变量存储一个字符串。其实在C语言中没有专门的字符串类型，我们只能使用数组或者指针来间接地存储字符串。**

在这里讲字符串很矛盾，虽然我们暂时还没有学到数组和指针，无法从原理上深入分析，但是字符串是常用的，又不得不说一下。所以本节我不会讲解太多，大家只需要死记硬背下面的两种表示形式即可：

```C
char str1[] = "http://c.biancheng.net";
char *str2 = "C语言中文网";
```

str1 和 str2 是字符串的名字，后边的[ ]和前边的*是固定的写法。初学者暂时可以认为这两种存储方式是等价的，它们都可以通过专用的 puts 函数和通用的 printf 函数输出。

完整的字符串演示：

```C
#include <stdio.h>
int main()
{
    char web_url[] = "http://c.biancheng.net";
    char *web_name = "C语言中文网";
    puts(web_url);
    puts(web_name);
    printf("%s\n%s\n", web_url, web_name);
    return 0;
}
```

## C语言处理中文字符

大部分C语言教材对中文字符的处理讳莫如深，甚至只字不提，导致很多初学者认为C语言只能处理英文，而不支持中文。其实C语言是一门全球化的编程语言，它支持世界上任何一个国家的语言文化，包括中文、日语、韩语等。

### 中文字符的存储

正确地存储中文字符需要解决两个问题。

#### 1) 足够长的数据类型

char 只能处理 ASCII 编码中的英文字符，是因为 char 类型太短，只有一个字节，容纳不下我大中华几万个汉字，要想处理中文字符，必须得使用更长的数据类型。

一个字符在存储之前会转换成它在字符集中的编号，而这样的编号是一个整数，所以我们可以用整数类型来存储一个字符，比如 unsigned short、unsigned int、unsigned long 等。

#### 2) 选择包含中文的字符集

C语言规定，对于汉语、日语、韩语等 ASCII 编码之外的单个字符，也就是专门的字符类型，要使用宽字符的编码方式。常见的宽字符编码有 UTF-16 和 UTF-32，它们都是基于 Unicode 字符集的，能够支持全球的语言文化。

在真正实现时，微软编译器（内嵌于 Visual Studio 或者 Visual C++ 中）采用 UTF-16 编码，使用 2 个字节存储一个字符，用 unsigned short 类型就可以容纳。GCC、LLVM/Clang（内嵌于 Xcode 中）采用 UTF-32 编码，使用 4 个字节存储字符，用 unsigned int 类型就可以容纳。

> 对于编号较小的字符，UTF-16 采用两个字节存储；对于编号较大的字符，UTF-16 使用四个字节存储。但是，全球常用的字符也就几万个，使用两个字节存储足以，只有极其罕见，或者非常古老的字符才会用到四个字节。

> 微软编译器使用两个字节来存储 UTF-16 编码的字符，虽然不能囊括所有的 Unicode 字符，但是也足以容纳全球的常见字符了，基本满足了软件开发的需求。使用两个字节存储的另外一个好处是可以节省内存，而使用四个字节会浪费 50% 以上的内存。

你看，不同的编译器可以使用不同的整数类型。如果我们的代码使用 unsigned int 来存储宽字符，那么在微软编译器下就是一种浪费；如果我们的代码使用 unsigned short 来存储宽字符，那么在 GCC、LLVM/Clang 下就不够。

为了解决这个问题，C语言推出了一种新的类型，叫做 wchar_t。w 是 wide 的首字母，t 是 type 的首字符，wchar_t 的意思就是宽字符类型。wchar_t 的长度由编译器决定：

- 在微软编译器下，它的长度是 2，等价于 unsigned short；
- 在GCC、LLVM/Clang 下，它的长度是 4，等价于 unsigned int。

wchar_t 其实是用 typedef 关键字定义的一个别名，我们会在《C语言typedef：给类型起一个别名》一节中深入讲解，大家暂时只需要记住，wchar_t 在不同的编译器下长度不一样。

上节我们讲到，单独的字符由单引号' '包围，例如'B'、'@'、'9'等；但是，这样的字符只能使用 ASCII 编码，要想使用宽字符的编码方式，就得加上L前缀，例如L'A'、L'9'、L'中'、L'国'、L'。'。

注意，加上L前缀后，所有的字符都将成为宽字符，占用 2 个字节或者 4 个字节的内存，包括 ASCII 中的英文字符。

下面的例子演示了如何存储宽字符（注意引入 <wchar.h> 头文件）：

```C
wchar_t a = L'A';  //英文字符（基本拉丁字符）
wchar_t b = L'9';  //英文数字（阿拉伯数字）
wchar_t c = L'中';  //中文汉字
wchar_t d = L'国';  //中文汉字
wchar_t e = L'。';  //中文标点
wchar_t f = L'ヅ';  //日文片假名
wchar_t g = L'♥';  //特殊符号
wchar_t h = L'༄';  //藏文
```

在以后的编程中，我们将不加L前缀的字符称为窄字符，将加上L前缀的字符称为宽字符。窄字符使用 ASCII 编码，宽字符使用 UTF-16 或者 UTF-32 编码。

### 宽字符的输出

putchar、printf 只能输出不加L前缀的窄字符，对加了L前缀的宽字符无能为力，我们必须使用 <wchar.h> 头文件中的宽字符输出函数，它们分别是 putwchar 和 wprintf：

- putwchar 函数专门用来输出一个宽字符，它和 putchar 的用法类似；
- wprintf 是通用的、格式化的宽字符输出函数，它除了可以输出单个宽字符，还可以输出宽字符串（稍后讲解）。宽字符对应的格式控制符为%lc。

另外，在输出宽字符之前还要使用 setlocale 函数进行本地化设置，告诉程序如何才能正确地处理各个国家的语言文化。由于大家基础还不够，关于本地化设置的内容我们不再展开讲解，请大家先记住这种写法。

如果希望设置为中文简体环境，在 Windows 下请写作：
```C
setlocale(LC_ALL, "zh-CN");
```

在 Linux 和 Mac OS 下请写作：

```C
setlocale(LC_ALL, "zh_CN");
```

setlocale 函数位于 <locale.h> 头文件中，我们必须引入它。

下面的代码完整地演示了宽字符的输出：
```C
#include <wchar.h>
#include <locale.h>
int main(){
    wchar_t a = L'A';  //英文字符（基本拉丁字符）
    wchar_t b = L'9';  //英文数字（阿拉伯数字）
    wchar_t c = L'中';  //中文汉字
    wchar_t d = L'国';  //中文汉字
    wchar_t e = L'。';  //中文标点
    wchar_t f = L'ヅ';  //日文片假名
    wchar_t g = L'♥';  //特殊符号
    wchar_t h = L'༄';  //藏文

    //将本地环境设置为简体中文
    setlocale(LC_ALL, "zh_CN");
    //使用专门的 putwchar 输出宽字符
    putwchar(a);  putwchar(b);  putwchar(c);  putwchar(d);
    putwchar(e);  putwchar(f);  putwchar(g);  putwchar(h);
    putwchar(L'\n');  //只能使用宽字符

    //使用通用的 wprintf 输出宽字符
    wprintf(
        L"Wide chars: %lc %lc %lc %lc %lc %lc %lc %lc\n",  //必须使用宽字符串
        a, b, c, d, e, f, g, h
    );


    return 0;
}
```

运行结果：
A9中国。ヅ♥༄
Wide chars: A 9 中 国 。 ヅ ♥ ༄

### 宽字符串

给字符串加上L前缀就变成了宽字符串，它包含的每个字符都是宽字符，一律采用 UTF-16 或者 UTF-32 编码。输出宽字符串可以使用 <wchar.h> 头文件中的 wprintf 函数，对应的格式控制符是%ls。

下面的代码演示了如何使用宽字符串：

```C
#include <wchar.h>
#include <locale.h>
int main(){
    wchar_t web_url[] = L"http://c.biancheng.net";
    wchar_t *web_name = L"C语言中文网";

    //将本地环境设置为简体中文
    setlocale(LC_ALL, "zh_CN");
    //使用通用的 wprintf 输出宽字符
    wprintf(L"web_url: %ls \nweb_name: %ls\n", web_url, web_name);
    return 0;
}
```

运行结果：
web_url: http://c.biancheng.net
web_name: C语言中文网

其实，不加L前缀的窄字符串也可以处理中文，它和加上了L前缀的宽字符串有什么区别呢？我们将在下节《C语言到底使用什么编码？谁说C语言使用ASCII码，真是荒谬！》中详细讲解。
