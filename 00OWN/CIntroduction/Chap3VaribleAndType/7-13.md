## C语言整数的取值范围以及数值溢出

short、int、long 是C语言中常用的三种整数类型，分别称为短整型、整型、长整型。

在现代操作系统中，short、int、long 的长度分别是 2、4、4 或者 8，它们只能存储有限的数值，当数值过大或者过小时，超出的部分会被直接截掉，数值就不能正确存储了，我们将这种现象称为溢出（Overflow）。

溢出的简单理解就是，向木桶里面倒入了过量的水，木桶盛不了了，水就流出来了。

要想知道数值什么时候溢出，就得先知道各种整数类型的取值范围。

### 无符号数的取值范围

计算无符号数（unsigned 类型）的取值范围（或者说最大值和最小值）很容易，将内存中的所有位（Bit）都置为 1 就是最大值，都置为 0 就是最小值。

以 unsigned char 类型为例，它的长度是 1，占用 8 位的内存，所有位都置为 1 时，它的值为 28 - 1 = 255，所有位都置为 0 时，它的值很显然为 0。由此可得，unsigned char 类型的取值范围是 0~255。

> 前面我们讲到，char 是一个字符类型，是用来存放字符的，但是它同时也是一个整数类型，也可以用来存放整数，请大家暂时先记住这一点，更多细节我们将在《C语言中的字符（char）》一节中介绍。

有读者可能会对 unsigned char 的最大值有疑问，究竟是怎么计算出来的呢？下面我就讲解一下这个小技巧。

将 unsigned char 的所有位都置为 1，它在内存中的表示形式为1111 1111，最直接的计算方法就是：
```
2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 = 255
```

这种“按部就班”的计算方法虽然有效，但是比较麻烦，如果是 8 个字节的 long 类型，那足够你计算半个小时的了。

我们不妨换一种思路，先给 1111 1111 加上 1，然后再减去 1，这样一增一减正好抵消掉，不会影响最终的值。

给 1111 1111 加上 1 的计算过程为：
```
0B1111 1111 + 0B1 = 0B1 0000 0000 = 28 = 256
```
可以发现，1111 1111 加上 1  后需要向前进位（向第 9 位进位），剩下的 8 位都变成了 0，这样一来，只有第 9 位会影响到数值的计算，剩下的 8 位对数值都没有影响。第 9 位的权值计算起来非常容易，就是：

```
2^(9-1) = 2^8 = 256
```

然后再减去 1：
```
2^8 - 1 = 256 - 1 = 255
```

加上 1 是为了便于计算，减去 1 是为了还原本来的值；当内存中所有的位都是 1 时，这种“凑整”的技巧非常实用。

按照这种巧妙的方法，我们可以很容易地计算出所有无符号数的取值范围（括号内为假设的长度）：

||unsigned char|unsigned short|unsigned int（4字节）|unsigned long（8字节）|
|---|---|---|
|最小值|0|0|0|0|
|最大值|2^8 - 1 = 255|2^16 - 1 = 65,535 ≈ 6.5万|2^32 - 1 = 4,294,967,295 ≈ 42亿|2^64 - 1 ≈ 1.84×10^19|

###有符号数的取值范围
有符号数以补码的形式存储，计算取值范围也要从补码入手。我们以 char 类型为例，从下表中找出它的取值范围：

|补码|反码|原码|值|
|--|
|1111 1111|1111 1110|1000 0001|-1|
|1111 1110|1111 1101|1000 0010|-2|
|1111 1101|1111 1100|1000 0011|-3|
|……|……|……|……|
|1000 0011|1000 0010|1111 1101|-125|
|1000 0010|1000 0001|1111 1110|-126|
|1000 0001|1000 0000|1111 1111|-127|
|1000 0000|--|--|-128|
|0111 1111|0111 1111|0111 1111|127|
|0111 1110|0111 1110|0111 1110|126|
|0111 1101|0111 1101|0111 1101|125|
|……|……|……|……|
|0000 0010|0000 0010|0000 0010|2|
|0000 0001|0000 0001|0000 0001|1|
|0000 0000|0000 0000|0000 0000|0|

其次，我们再按照“传统”的方法计算一下 -128 的补码：

- -128 的数值位的原码是 1000 0000，共八位，而 char 的数值位只有七位，所以最高位的 1 会覆盖符号位，数值位剩下 000 0000。最终，-128 的原码为 1000 0000。
- 接着很容易计算出反码，为 1111 1111。
- 反码转换为补码时，数值位要加上 1，变为 1000 0000，而 char 的数值位只有七位，所以最高位的 1 会再次覆盖符号位，数值位剩下 000 0000。最终求得的 -128 的补码是 1000 0000。

-128 从原码转换到补码的过程中，符号位被 1 覆盖了两次，而负数的符号位本来就是 1，被 1 覆盖多少次也不会影响到数字的符号。

你看，虽然从 1000 0000 这个补码推算不出 -128，但是从 -128 却能推算出 1000 0000 这个补码，这么多么的奇妙，-128 这个特殊值选得恰到好处。

负数在存储之前要先转换为补码，“从 -128 推算出补码 1000 0000”这一点非常重要，这意味着 -128 能够正确地转换为补码，或者说能够正确的存储。

### 关于零值和最小值
